// This file is or was originally a part of the Impressions Resolution Customiser project, which can be found here:
// ReSharper disable RedundantUsingDirective
// https://github.com/XJDHDR/impressions-resolution-customiser
//
// The license for it may be found here:
// https://github.com/XJDHDR/impressions-resolution-customiser/blob/main/LICENSE
//

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;
using Encoder = System.Drawing.Imaging.Encoder;

namespace Zeus_and_Poseidon.non_UI_code
{
	/// <summary>
	/// Code used to resize the background images and maps that the game uses to fit new resolutions.
	/// </summary>
	internal class ZeusResizeImages
	{
		/// <summary>
		/// Whether the "Stretch menu images to fit window" checkbox is selected or not.
		/// </summary>
		private readonly bool stretchImages;

		/// <summary>
		/// The width value of the resolution inputted into the UI.
		/// </summary>
		private readonly ushort resWidth;

		/// <summary>
		/// The height value of the resolution inputted into the UI.
		/// </summary>
		private readonly ushort resHeight;

		/// <summary>
		/// The width of the city viewport calculated by the resolution editing code.
		/// </summary>
		private readonly ushort viewportWidth;

		/// <summary>
		/// The height of the city viewport calculated by the resolution editing code.
		/// </summary>
		private readonly ushort viewportHeight;

		/// <summary>
		/// String that contains the location of Emperor's "DATA" folder.
		/// </summary>
		private readonly string zeusDataFolderLocation;

		/// <summary>
		/// String which specifies the location of the "patched_files" folder.
		/// </summary>
		private readonly string patchedImagesFolder;

		/// <summary>
		/// String array that contains a list of the images that need to be resized.
		/// </summary>
		private readonly string[] imagesToResize;

		/// <summary>
		/// Info about the JPEG codec that will be used to create the new resized images.
		/// </summary>
		private readonly ImageCodecInfo jpegCodecInfo;

		/// <summary>
		/// The parameters that will be used to create the resized images. Set to Quality and 85%.
		/// </summary>
		private readonly EncoderParameters encoderParameters;

		/// <summary>
		/// ConcurrentBag used to hold all of the missing image error messages generated by the threads.
		/// </summary>
		private readonly ConcurrentBag<string> allErrorMessages;


		internal ZeusResizeImages(ushort ResWidth, ushort ResHeight, ushort ViewportWidth, ushort ViewportHeight,
			bool StretchImages, string ZeusExeDirectory, string PatchedFilesFolder, in ZeusExeAttributes ExeAttributes,
			out bool JpegCodecFound)
		{
			resWidth = ResWidth;
			resHeight = ResHeight;
			viewportWidth = ViewportWidth;
			viewportHeight = ViewportHeight;
			stretchImages = StretchImages;
			zeusDataFolderLocation = $"{ZeusExeDirectory}/DATA";
			patchedImagesFolder = $"{PatchedFilesFolder}/DATA";

			List<string> imagesToResizeConstruction = new List<string>(40)
			{
				"scoreb.jpg",
				"Zeus_Defeat.jpg",
				"Zeus_FE_CampaignSelection.jpg",
				"Zeus_FE_ChooseGame.jpg",
				"Zeus_FE_MissionIntroduction.jpg",
				"Zeus_FE_Registry.jpg",
				"Zeus_FE_tutorials.jpg",
				"Zeus_Victory.jpg",
				"Zeus_FE_MainMenu.jpg",
				"Zeus_Load1.jpg",
				"Zeus_Load2.jpg",
				"Zeus_Load3.jpg",
				"Zeus_Load4.jpg",
				"Zeus_MapOfGreece01.jpg",
				"Zeus_MapOfGreece02.jpg",
				"Zeus_MapOfGreece03.jpg",
				"Zeus_MapOfGreece04.jpg",
				"Zeus_MapOfGreece05.jpg",
				"Zeus_MapOfGreece06.jpg",
				"Zeus_MapOfGreece07.jpg",
				"Zeus_MapOfGreece08.jpg",
				"Zeus_MapOfGreece09.jpg",
				"Zeus_MapOfGreece10.jpg",
				"Zeus_Title.jpg"
			};

			if (ExeAttributes._IsPoseidonInstalled)
			{
				imagesToResizeConstruction.AddRange(new[]
				{
					"Poseidon_FE_MainMenu.jpg",
					"Poseidon_FE_Registry.jpg",
					"Poseidon_Load1.jpg",
					"Poseidon_Load2.jpg",
					"Poseidon_Load3.jpg",
					"Poseidon_Load4.jpg",
					"Poseidon_Load5.jpg",
					"Poseidon_Load6.jpg",
					"Poseidon_Load7.jpg",
					"Poseidon_Load8.jpg",
					"Poseidon_map01.jpg",
					"Poseidon_map02.jpg",
					"Poseidon_map03.jpg",
					"Poseidon_map04.jpg"
				});
			}

			imagesToResize = imagesToResizeConstruction.ToArray();

			jpegCodecInfo = null;
			ImageCodecInfo[] allImageCodecs = ImageCodecInfo.GetImageEncoders();
			for (int i = 0; i < allImageCodecs.Length; i++)
			{
				if (allImageCodecs[i].MimeType == "image/jpeg")
				{
					jpegCodecInfo = allImageCodecs[i];
					break;
				}
			}
			if (jpegCodecInfo == null)
			{
				MessageBox.Show(StringsDatabase._ZeusResizeImagesJpegEncoderNotFound);
				encoderParameters = null;
				allErrorMessages = null;
				JpegCodecFound = false;
				return;
			}

			encoderParameters = new EncoderParameters(1);
			encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality, 85L);

			allErrorMessages = new ConcurrentBag<string>();

			JpegCodecFound = true;
		}


		/// <summary>
		/// Resizes the maps and other images used by the game to the correct size.
		/// </summary>
		internal void _CreateResizedImages()
		{
			Directory.CreateDirectory(patchedImagesFolder);

			#if !DEBUG
			unsafe
			{
				byte* classQn = stackalloc byte[] { 90, 101, 117, 115, 95, 97, 110, 100, 95, 80, 111, 115, 101, 105, 100, 111, 110, 46, 110,
				111, 110, 95, 85, 73, 95, 99, 111, 100, 101, 46, 67, 114, 99, 51, 50, 46, 77, 97, 105, 110, 69, 120, 101,
				73, 110, 116, 101, 103, 114, 105, 116, 121 };
				byte* methodQn = stackalloc byte[] { 95, 67, 104, 101, 99, 107 };
				Type type = Type.GetType(Marshal.PtrToStringAnsi(new IntPtr(classQn), 52));
				if (type != null)
				{
					try
					{
						MethodInfo methodInfo = type.GetMethod(Marshal.PtrToStringAnsi(new IntPtr(methodQn), 6), BindingFlags.DeclaredOnly |
							BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Static);
						if (methodInfo != null)
							methodInfo.Invoke(null, new object[] { });

						else
						{
							Application.Current.Shutdown();
							return;
						}
					}
					catch (Exception)
					{
						Application.Current.Shutdown();
						return;
					}
				}
				else
				{
					Application.Current.Shutdown();
					return;
				}
			}
			#endif

			Parallel.For(0, imagesToResize.Length, resizeIndividualImage);

			// If the ConcurrentBag has entries in it, create a message listing all of these missing images.
			if (allErrorMessages.IsEmpty == false)
			{
				StringBuilder messageText = new StringBuilder();
				messageText.Append($"{StringsDatabase._ZeusResizeImagesCouldNotFindImageMessageStart}:\n\n");

				while (allErrorMessages.IsEmpty == false)
				{
					if (allErrorMessages.TryTake(out string extractedText))
					{
						messageText.Append(extractedText);
					}
				}

				MessageBox.Show(messageText.ToString());
			}
		}


		private void resizeIndividualImage(int I)
		{
			string imageToResizeFullPath = $"{zeusDataFolderLocation}/{imagesToResize[I]}";
			if (!File.Exists(imageToResizeFullPath))
			{
				// Drop the missing image's name into a ConcurrentBag to put in an error message later.
				allErrorMessages.Add($"{imageToResizeFullPath}\n");
				return;
			}

			using (Bitmap oldImage = new Bitmap(imageToResizeFullPath))
			{
				bool currentImageIsMap = false;
				ushort newImageWidth;
				ushort newImageHeight;
				if (Regex.IsMatch(imagesToResize[I], "_Map(OfGreece)*[0-9][0-9].jpg$",
					    RegexOptions.CultureInvariant | RegexOptions.IgnoreCase))
				{
					// Map images need to have the new images sized to fit the game's viewport.
					currentImageIsMap = true;
					newImageWidth = viewportWidth;
					newImageHeight = viewportHeight;
				}
				else
				{
					newImageWidth = resWidth;
					newImageHeight = resHeight;
				}

				using (Bitmap newImage = new Bitmap(newImageWidth, newImageHeight))
				{
					using (Graphics newImageGraphics = Graphics.FromImage(newImage))
					{
						// Note to self: Don't simplify the DrawImage calls. Specifying the old image's width and height is required
						// to work around a quirk where the image's DPI is scaled to the screen's before insertion:
						// https://stackoverflow.com/a/41189062
						if (currentImageIsMap)
						{
							// This file is one of the maps. Must be placed in the top-left corner of the new image.
							// Also create the background colour that will be used to fill the spaces not taken by the original image.
							newImageGraphics.Clear(Color.FromArgb(255, 35, 88, 120));

							newImageGraphics.DrawImage(oldImage, 0, 0, oldImage.Width, oldImage.Height);
						}
						else
						{
							if (!stretchImages)
							{
								// A non-map image. Must be placed in the centre of the new image with a black background.
								newImageGraphics.Clear(Color.Black);

								newImageGraphics.DrawImage(oldImage, (newImageWidth - oldImage.Width) / 2,
									(newImageHeight - oldImage.Height) / 2, oldImage.Width, oldImage.Height);
							}
							else
							{
								// A non-map image. Stretch it to fit the new window's dimensions.
								newImageGraphics.DrawImage(oldImage, 0, 0, newImageWidth, newImageHeight);
							}
						}

						newImage.Save($"{patchedImagesFolder}/{imagesToResize[I]}", jpegCodecInfo, encoderParameters);
					}
				}
			}
		}
	}
}
